---
// src/components/NoiseEffect.astro
---

<canvas id="noise-canvas"></canvas>

<script>
  const canvas = document.getElementById("noise-canvas") as HTMLCanvasElement;
  const gl = canvas.getContext("webgl");

  if (!gl) {
    console.error("WebGL not supported!");
    // WebGLがサポートされていない場合のフォールバック処理をここに追加できます
  } else {
    // --- WebGLの初期化 ---
    // ビューポートの設定
    gl.viewport(0, 0, canvas.width, canvas.height);
    // クリアカラーの設定 (例: 黒)
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // --- シェーダーの準備 ---
    // 頂点シェーダーのソースコード
    const vsSource = `
      attribute vec4 aVertexPosition;
      void main() {
        gl_Position = aVertexPosition;
      }
    `;

    // フラグメントシェーダーのソースコード (ここにノイズ処理を記述)
    const fsSource = `
      precision mediump float; // 精度を指定

      uniform vec2 u_resolution; // 解像度
      uniform float u_time;     // 時間 (アニメーション用)

      // 簡易的なランダム関数 (より高度なノイズ関数も検討可能)
      float random(vec2 st) {
        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
      }

      void main() {
        vec2 st = gl_FragCoord.xy / u_resolution; // 0.0 - 1.0 の範囲に正規化
        float rnd = random(st + u_time * 0.01); // 時間で変化するノイズ

        gl_FragColor = vec4(rnd, rnd, rnd, 1.0); // グレースケールのノイズ
      }
    `;

    // シェーダープログラムを作成・リンクするヘルパー関数
    function initShaderProgram(
      gl: WebGLRenderingContext,
      vsSource: string,
      fsSource: string,
    ): WebGLProgram | null {
      const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

      if (!vertexShader || !fragmentShader) return null;

      const shaderProgram = gl.createProgram();
      if (!shaderProgram) {
        console.error("Unable to create the shader program.");
        return null;
      }
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);

      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        console.error(
          "Unable to initialize the shader program: " +
            gl.getProgramInfoLog(shaderProgram),
        );
        return null;
      }
      return shaderProgram;
    }

    // シェーダーをコンパイルするヘルパー関数
    function loadShader(
      gl: WebGLRenderingContext,
      type: number,
      source: string,
    ): WebGLShader | null {
      const shader = gl.createShader(type);
      if (!shader) {
        console.error("Unable to create shader.");
        return null;
      }
      gl.shaderSource(shader, source);
      gl.compileShader(shader);

      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(
          "An error occurred compiling the shaders: " +
            gl.getShaderInfoLog(shader),
        );
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

    if (shaderProgram) {
      // --- 頂点データの準備 ---
      // 画面全体を覆う矩形のための頂点座標 (-1.0 から 1.0 の範囲)
      const positions = [-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0];
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(positions),
        gl.STATIC_DRAW,
      );

      // --- シェーダープログラムにデータを渡す準備 ---
      const programInfo = {
        program: shaderProgram,
        attribLocations: {
          vertexPosition: gl.getAttribLocation(
            shaderProgram,
            "aVertexPosition",
          ),
        },
        uniformLocations: {
          resolution: gl.getUniformLocation(shaderProgram, "u_resolution"),
          time: gl.getUniformLocation(shaderProgram, "u_time"),
        },
      };

      // --- 描画ループ ---
      function render(time: number) {
        time *= 0.001; // 秒に変換

        if (!gl) {
          return;
        }

        // Canvas のサイズを CSS の表示サイズに合わせる (リサイズ対応)
        if (
          canvas.width !== canvas.clientWidth ||
          canvas.height !== canvas.clientHeight
        ) {
          canvas.width = canvas.clientWidth;
          canvas.height = canvas.clientHeight;
          gl.viewport(0, 0, canvas.width, canvas.height);
        }

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(programInfo.program);

        // 頂点バッファを設定
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(
          programInfo.attribLocations.vertexPosition,
          2, // 各頂点の成分数 (2Dなのでx, y)
          gl.FLOAT, // データ型
          false, // 正規化するかどうか
          0, // ストライド (0なら上記の成分数とデータ型から自動計算)
          0, // バッファのオフセット
        );
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

        // uniform 変数を設定
        if (programInfo.uniformLocations.resolution) {
          gl.uniform2f(
            programInfo.uniformLocations.resolution,
            canvas.width,
            canvas.height,
          );
        }
        if (programInfo.uniformLocations.time) {
          gl.uniform1f(programInfo.uniformLocations.time, time);
        }

        // 描画 (矩形を描画するために2つの三角形を描画)
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); // 4は頂点の数

        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
    }
  }
</script>

<style>
  #noise-canvas {
    width: 100%; /* または固定サイズ */
    height: 300px; /* または固定サイズ */
    display: block; /* インライン要素の余白を避ける */
  }
</style>
